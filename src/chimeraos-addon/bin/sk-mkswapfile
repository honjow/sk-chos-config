#!/bin/bash

set -e

# 定义常用路径
FRZR_ROOT="/frzr_root"
SWAP_DIR="${FRZR_ROOT}/swap"
SWAP_FILE="${SWAP_DIR}/swapfile"
SUSPEND_SERVICE="/etc/systemd/system/systemd-suspend.service"

# 简单的错误处理
trap 'echo "在第 $LINENO 行发生错误"; exit 1' ERR

# 恢复备份函数
restore_backup() {
    local backup_path="$1"
    if [ -n "$backup_path" ] && [ -f "$backup_path" ]; then
        echo "正在恢复备份..."
        rm -f "$SWAP_FILE"
        mv "$backup_path" "$SWAP_FILE"
        if swapon "$SWAP_FILE"; then
            echo "备份恢复成功"
            return 0
        else
            echo "备份恢复失败"
            return 1
        fi
    else
        echo "没有可用的备份文件"
        return 1
    fi
}

if [ "$EUID" -ne 0 ]; then
    echo "此脚本必须以 root 权限或通过 sudo 运行"
    exit 1
fi

SIZE=$1

source /etc/sk-chos/sk-chos.conf
default_swapfile_size=${4:-$SWAP_FILE_SIZE}

# 检查并获取RAM信息
# Note: dmidecode may output "GiB" (IEC binary) or "GB" (SI decimal), need to match both
get_ram_size() {
    local ram_size=0
    
    if command -v dmidecode &>/dev/null; then
        # Method 1: dmidecode -t 19 (Memory Array Mapped Address) - most reliable, direct total
        local range_size
        range_size=$(dmidecode -t 19 2>/dev/null | grep -E "Range Size:" | head -1 | grep -oE "[0-9]+" | head -1)
        if [ -n "$range_size" ] && [ "$range_size" -gt 0 ] 2>/dev/null; then
            ram_size=$range_size
        fi
        
        # Method 2: dmidecode -t 17 (Memory Device) - sum all modules
        if [ -z "$ram_size" ] || [ "$ram_size" -eq 0 ] 2>/dev/null; then
            local ram_info
            ram_info=$(dmidecode -t 17 2>/dev/null | tr -d '\t' | grep -E "^Size: [0-9]+ [MG]i?B" | awk '{print $2}')
            if [ -n "$ram_info" ]; then
                ram_size=$(echo "$ram_info" | awk '{sum += $1} END {print sum}')
            fi
        fi
    fi
    
    # Method 3: lshw as secondary fallback
    if [ -z "$ram_size" ] || [ "$ram_size" -eq 0 ] 2>/dev/null; then
        if command -v lshw &>/dev/null; then
            local lshw_size
            # Use -short format and look for "System Memory" line
            lshw_size=$(lshw -class memory -short 2>/dev/null | grep -E "System Memory" | grep -oE "[0-9]+GiB" | grep -oE "[0-9]+")
            if [ -n "$lshw_size" ] && [ "$lshw_size" -gt 0 ] 2>/dev/null; then
                ram_size=$lshw_size
            fi
        fi
    fi
    
    # Method 4: /proc/meminfo as final fallback (returns available memory, not physical)
    if [ -z "$ram_size" ] || [ "$ram_size" -eq 0 ] 2>/dev/null; then
        echo "警告: 无法获取物理内存大小，使用 /proc/meminfo 作为兜底" >&2
        local mem_kb
        mem_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        # Convert KB to GB (round up to ensure sufficient swap)
        ram_size=$(( (mem_kb + 1048575) / 1048576 ))
    fi
    
    echo "$ram_size"
}

ram_size_num=$(get_ram_size)
echo "检测到 RAM 大小: $ram_size_num GiB"

custom_swapfile_size="$SIZE"

if [ -f "$SUSPEND_SERVICE" ]; then
    if cat "$SUSPEND_SERVICE" | grep -q "systemd-sleep hibernate" || \
       cat "$SUSPEND_SERVICE" | grep -q "systemd-sleep suspend-then-hibernate"; then
        default_swapfile_size=$ram_size_num
    fi
fi

if [ -n "$custom_swapfile_size" ]; then
    if [ "$custom_swapfile_size" -lt 0 ]; then
        echo "SIZE 小于 0, 使用 RAM 大小: $ram_size_num GiB"
        swapfile_size=$ram_size_num
    elif [ "$custom_swapfile_size" -gt "$ram_size_num" ]; then
        echo "SIZE 大于 RAM 大小, 使用 RAM 大小: $ram_size_num GiB"
        swapfile_size=$ram_size_num
    elif [ "$custom_swapfile_size" -eq 0 ]; then
        echo "SIZE 等于 0, 使用默认大小: $default_swapfile_size GiB"
        swapfile_size=$default_swapfile_size
    else
        echo "SIZE 等于 $custom_swapfile_size GiB"
        swapfile_size=$custom_swapfile_size
    fi
else
    swapfile_size=$default_swapfile_size
fi

echo "交换文件大小: $swapfile_size GiB"

# 验证swap大小
if ! [[ "$swapfile_size" =~ ^[0-9]+$ ]] || [ "$swapfile_size" -lt 1 ]; then
    echo "错误: 交换文件大小必须是大于等于1的正整数 (GiB)"
    exit 1
fi

# 检查可用空间
available_space=$(df -BG "$FRZR_ROOT" | awk 'NR==2 {print $4}' | tr -d 'G')
if [ "$available_space" -lt "$swapfile_size" ]; then
    echo "错误: 空间不足。需要: ${swapfile_size}G, 可用: ${available_space}G"
    exit 1
fi

# 检查并创建BTRFS子卷
if [ ! -d "$SWAP_DIR" ]; then
    echo "正在创建 BTRFS 子卷 $SWAP_DIR..."
    btrfs subvolume create "$SWAP_DIR" || { echo "创建子卷失败"; exit 1; }
else
    if ! btrfs subvolume show "$SWAP_DIR" &>/dev/null; then
        echo "正在重新创建 BTRFS 子卷..."
        rm -rf "$SWAP_DIR"
        btrfs subvolume create "$SWAP_DIR" || { echo "创建子卷失败"; exit 1; }
    fi
fi

chattr +C "$SWAP_DIR"

backup_name=""

# 处理现有的swapfile
if [ -f "$SWAP_FILE" ]; then
    echo "发现已存在的交换文件"
    
    # 创建备份（如果有足够空间）
    if [ "$available_space" -gt "$((swapfile_size * 2))" ]; then
        backup_name="${SWAP_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
        echo "正在创建备份: $backup_name"
        cp "$SWAP_FILE" "$backup_name" || echo "警告: 备份失败，继续执行"
    fi

    echo "正在禁用现有交换文件..."
    swapoff "$SWAP_FILE" || true
    rm -f "$SWAP_FILE"
fi

# 创建和启用新的swapfile
echo "正在创建新的交换文件..."
if mkswapfile "$SWAP_FILE" "$swapfile_size"GiB; then
    echo "正在启用交换文件..."
    if swapon "$SWAP_FILE"; then
        # 如果创建和启用都成功了，删除备份
        if [ -n "$backup_name" ] && [ -f "$backup_name" ]; then
            echo "创建成功，删除备份文件..."
            rm -f "$backup_name"
        fi
    else
        echo "启用交换文件失败，尝试恢复备份..."
        restore_backup "$backup_name" || exit 1
    fi
else
    echo "创建交换文件失败，尝试恢复备份..."
    restore_backup "$backup_name" || exit 1
fi

echo "交换文件设置完成"