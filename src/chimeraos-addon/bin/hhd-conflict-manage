#!/bin/bash

# Manage resources that conflict with hhd (kernel modules, services).
# Companion service: follows hhd lifecycle via BindsTo=hhd.service
#
# - start: blacklist conflicting modules, unload them, stop conflicting services,
#          remove power key ignore (hhd handles it), restart listed services
# - stop:  remove blacklist, reload modules, unmask conflicting services,
#          restore power key ignore, restart listed services (2s deferred)
#
# Service entry format:
#   "servicename"            - system service (managed via systemctl)
#   "user:UID:servicename"   - user service (managed via systemctl --user as UID)


HHD_BLACKLIST_DIR="/run/modprobe.d"
HHD_BLACKLIST_FILE="${HHD_BLACKLIST_DIR}/hhd-conflicts.conf"
POWERKEY_IGNORE_CONF="/etc/systemd/logind.conf.d/zzz-handle-power-key-ignore.conf"

CONFLICT_MODULES=(
    asus_ally_hid
    hid_lenovo_go
    hid_lenovo_go_s
)

CONFLICT_SERVICES=(
    inputplumber
)

# Services to restart when hhd starts (immediately after conflicts are stopped).
# Format: "servicename" or "user:UID:servicename"
RESTART_ON_START_SERVICES=(
    "user:1000:steamos-powerbuttond"
)

# Services to restart when hhd stops (2s deferred, to allow modules to reload first).
# Format: "servicename" or "user:UID:servicename"
RESTART_ON_STOP_SERVICES=(
    inputplumber
    "user:1000:steamos-powerbuttond"
)

log() {
    echo "[hhd-conflict-manage] $*"
}

is_module_loaded() {
    lsmod | grep -q "^${1}[[:space:]]"
}

# --- User service helpers ---

# Invoke systemctl --user as the given UID using their session bus.
run_user_systemctl() {
    local uid="$1"
    shift
    local username
    username=$(getent passwd "$uid" | cut -d: -f1)
    if [[ -z "$username" ]]; then
        log "Warning: no user found for uid ${uid}"
        return 1
    fi
    XDG_RUNTIME_DIR="/run/user/${uid}" \
    DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/${uid}/bus" \
    runuser -u "$username" -- systemctl --user "$@"
}

# Restart a service entry immediately.
# Entry format: "servicename" or "user:UID:servicename"
restart_service_now() {
    local entry="$1"
    if [[ "$entry" == user:*:* ]]; then
        local uid="${entry#user:}"
        uid="${uid%%:*}"
        local svc="${entry#user:${uid}:}"
        if [[ "$(run_user_systemctl "$uid" is-enabled "$svc" 2>/dev/null)" == "masked" ]]; then
            log "Unmasking user service (uid=${uid}): ${svc}"
            run_user_systemctl "$uid" unmask "$svc" || true
        fi
        log "Restarting user service (uid=${uid}): ${svc}"
        run_user_systemctl "$uid" restart "$svc" \
            || log "Warning: failed to restart user service ${svc}"
    else
        if [[ "$(systemctl is-enabled "$entry" 2>/dev/null)" == "masked" ]]; then
            log "Unmasking service: ${entry}"
            systemctl unmask "$entry" || true
        fi
        log "Restarting service: ${entry}"
        systemctl restart "$entry" \
            || log "Warning: failed to restart ${entry}"
    fi
}

# Schedule a deferred restart (2s delay) for a service entry.
# Entry format: "servicename" or "user:UID:servicename"
# The actual restart logic runs via a self-call to avoid inline bash -c strings.
restart_service_deferred() {
    local entry="$1"
    if [[ "$entry" == user:*:* ]]; then
        local uid="${entry#user:}"
        uid="${uid%%:*}"
        local svc="${entry#user:${uid}:}"
        local unit_name="restart-user${uid}-${svc%.service}"
        if [[ -z "$(getent passwd "$uid")" ]]; then
            log "Warning: no user found for uid ${uid}, skipping deferred restart of ${svc}"
            return 0
        fi
        log "Scheduling deferred user service restart (uid=${uid}): ${svc}"
        systemd-run --no-block --on-active=2 --collect --unit="$unit_name" \
            "$0" _deferred-restart-user "$uid" "$svc" \
            || true
    else
        local unit_name="restart-${entry%.service}"
        log "Scheduling deferred restart: ${entry}"
        systemd-run --no-block --on-active=2 --collect --unit="$unit_name" \
            "$0" _deferred-restart-system "$entry" \
            || true
    fi
}

# Deferred restart handlers (invoked via systemd-run self-call).

_deferred_restart_user() {
    local uid="$1"
    local svc="$2"
    if [[ "$(run_user_systemctl "$uid" is-enabled "$svc" 2>/dev/null)" == "masked" ]]; then
        log "Unmasking user service (uid=${uid}): ${svc}"
        run_user_systemctl "$uid" unmask "$svc" || true
    fi
    log "Restarting user service (uid=${uid}): ${svc}"
    run_user_systemctl "$uid" restart "$svc" \
        || log "Warning: failed to restart user service ${svc}"
}

_deferred_restart_system() {
    local svc="$1"
    if systemctl is-active --quiet hhd-conflict-manage.service 2>/dev/null; then
        log "hhd is active, skipping deferred restart of ${svc}"
        return 0
    fi
    if [[ "$(systemctl is-enabled "$svc" 2>/dev/null)" == "masked" ]]; then
        log "Unmasking service: ${svc}"
        systemctl unmask "$svc" || true
    fi
    log "Restarting service: ${svc}"
    systemctl restart "$svc" \
        || log "Warning: failed to restart ${svc}"
}

# --- Module management ---

start_modules() {
    local blacklist_entries=()
    local loaded_modules=()

    for mod in "${CONFLICT_MODULES[@]}"; do
        blacklist_entries+=("blacklist ${mod}")
        if is_module_loaded "$mod"; then
            loaded_modules+=("$mod")
        fi
    done

    mkdir -p "$HHD_BLACKLIST_DIR"
    printf '%s\n' "${blacklist_entries[@]}" > "$HHD_BLACKLIST_FILE"

    if [[ ${#loaded_modules[@]} -eq 0 ]]; then
        log "No conflicting modules loaded"
        return 0
    fi

    log "Blocking and unloading: ${loaded_modules[*]}"

    for mod in "${loaded_modules[@]}"; do
        log "Unloading: ${mod}"
        modprobe -r "$mod" 2>/dev/null || log "Warning: failed to unload ${mod}"
    done
}

stop_modules() {
    if [[ ! -f "$HHD_BLACKLIST_FILE" ]]; then
        log "No blacklist file found, nothing to restore"
        return 0
    fi

    local modules=()
    while IFS= read -r line; do
        if [[ "$line" =~ ^blacklist[[:space:]]+(.+) ]]; then
            modules+=("${BASH_REMATCH[1]}")
        fi
    done < "$HHD_BLACKLIST_FILE"

    rm -f "$HHD_BLACKLIST_FILE"
    log "Removed blacklist file"

    for mod in "${modules[@]}"; do
        if ! is_module_loaded "$mod"; then
            log "Reloading: ${mod}"
            modprobe "$mod" 2>/dev/null || log "Warning: failed to reload ${mod}"
        fi
    done
}

# --- Service management ---

start_services() {
    for svc in "${CONFLICT_SERVICES[@]}"; do
        local unit_name="restart-${svc%.service}"
        systemctl stop "${unit_name}.timer" "${unit_name}.service" 2>/dev/null || true
    done

    for svc in "${CONFLICT_SERVICES[@]}"; do
        local svc_state
        svc_state=$(systemctl is-enabled "$svc" 2>/dev/null || true)
        if systemctl is-active --quiet "$svc" 2>/dev/null; then
            log "Stopping conflicting service: ${svc}"
            systemctl stop "$svc" 2>/dev/null || true
        fi
        log "Masking conflicting service: ${svc}"
        systemctl mask "$svc" 2>/dev/null || true
    done

    for entry in "${RESTART_ON_START_SERVICES[@]}"; do
        restart_service_now "$entry"
    done
}

stop_services() {
    for svc in "${CONFLICT_SERVICES[@]}"; do
        local svc_state
        svc_state=$(systemctl is-enabled "$svc" 2>/dev/null || true)
        if [[ "$svc_state" == "masked" ]]; then
            log "Unmasking service: ${svc}"
            systemctl unmask "$svc" 2>/dev/null || true
        fi
    done

    for entry in "${RESTART_ON_STOP_SERVICES[@]}"; do
        restart_service_deferred "$entry"
    done
}

# --- Power key management ---

reload_logind() {
    systemctl kill -s HUP systemd-logind 2>/dev/null || true
}

start_powerkey() {
    if [[ -f "$POWERKEY_IGNORE_CONF" ]]; then
        log "Removing power key ignore (hhd handles power key)"
        rm -f "$POWERKEY_IGNORE_CONF"
        reload_logind
    fi
}

stop_powerkey() {
    if [[ ! -f "$POWERKEY_IGNORE_CONF" ]]; then
        log "Restoring power key ignore"
        mkdir -p "$(dirname "$POWERKEY_IGNORE_CONF")"
        printf '[Login]\nHandlePowerKey=ignore\n' > "$POWERKEY_IGNORE_CONF"
        reload_logind
    fi
}

# --- Entry points ---

do_start() {
    start_modules
    start_powerkey
    start_services
}

do_stop() {
    stop_modules
    stop_powerkey
    stop_services
}

# Re-unload conflict modules after system resume.
# Called via systemd-sleep hook with a delay to allow USB re-enumeration.
do_post_resume() {
    if ! systemctl is-active --quiet hhd-conflict-manage.service 2>/dev/null; then
        log "Post-resume: hhd-conflict-manage not active, skipping"
        return 0
    fi
    log "Post-resume: re-checking conflict modules after resume"
    start_modules
}

case "${1}" in
    start)
        do_start
        ;;
    stop)
        do_stop
        ;;
    _post-resume)
        do_post_resume
        ;;
    _deferred-restart-user)
        _deferred_restart_user "${2}" "${3}"
        ;;
    _deferred-restart-system)
        _deferred_restart_system "${2}"
        ;;
    *)
        echo "Usage: $(basename "$0") {start|stop|_post-resume}"
        exit 1
        ;;
esac
