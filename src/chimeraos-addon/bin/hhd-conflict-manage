#!/bin/bash

# Manage resources that conflict with hhd (kernel modules, services).
# Companion service: follows hhd lifecycle via BindsTo=hhd.service
#
# - start: blacklist conflicting modules, unload them, stop conflicting services,
#          remove power key ignore (hhd handles it), restart listed services
# - stop:  remove blacklist, reload modules, unmask conflicting services,
#          restore power key ignore, restart listed services (2s deferred)
#
# Service entry format:
#   "servicename"            - system service (managed via systemctl)
#   "user:UID:servicename"   - user service (managed via systemctl --user as UID)


HHD_BLACKLIST_DIR="/run/modprobe.d"
HHD_BLACKLIST_FILE="${HHD_BLACKLIST_DIR}/hhd-conflicts.conf"
POWERKEY_IGNORE_CONF="/etc/systemd/logind.conf.d/zzz-handle-power-key-ignore.conf"

CONFLICT_MODULES=(
    asus_ally_hid
    hid_lenovo_go
    hid_lenovo_go_s
)

CONFLICT_SERVICES=(
    inputplumber
)

# Services to restart when hhd starts (immediately after conflicts are stopped).
# Format: "servicename" or "user:UID:servicename"
RESTART_ON_START_SERVICES=(
    "user:1000:steamos-powerbuttond"
)

# Services to restart when hhd stops (2s deferred, to allow modules to reload first).
# Format: "servicename" or "user:UID:servicename"
RESTART_ON_STOP_SERVICES=(
    inputplumber
    "user:1000:steamos-powerbuttond"
)

log() {
    echo "[hhd-conflict-manage] $*"
}

is_module_loaded() {
    lsmod | grep -q "^${1}[[:space:]]"
}

# --- User service helpers ---

# Invoke systemctl --user as the given UID using their session bus.
run_user_systemctl() {
    local uid="$1"
    shift
    local username
    username=$(getent passwd "$uid" | cut -d: -f1)
    if [[ -z "$username" ]]; then
        log "Warning: no user found for uid ${uid}"
        return 1
    fi
    XDG_RUNTIME_DIR="/run/user/${uid}" \
    DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/${uid}/bus" \
    runuser -u "$username" -- systemctl --user "$@"
}

# Restart a service entry immediately.
# Entry format: "servicename" or "user:UID:servicename"
restart_service_now() {
    local entry="$1"
    if [[ "$entry" == user:*:* ]]; then
        local uid="${entry#user:}"
        uid="${uid%%:*}"
        local svc="${entry#user:${uid}:}"
        if [[ "$(run_user_systemctl "$uid" is-enabled "$svc" 2>/dev/null)" == "masked" ]]; then
            log "Unmasking user service (uid=${uid}): ${svc}"
            run_user_systemctl "$uid" unmask "$svc" 2>/dev/null || true
        fi
        log "Restarting user service (uid=${uid}): ${svc}"
        run_user_systemctl "$uid" restart "$svc" 2>/dev/null \
            || log "Warning: failed to restart user service ${svc}"
    else
        if [[ "$(systemctl is-enabled "$entry" 2>/dev/null)" == "masked" ]]; then
            log "Unmasking service: ${entry}"
            systemctl unmask "$entry" 2>/dev/null || true
        fi
        log "Restarting service: ${entry}"
        systemctl restart "$entry" 2>/dev/null \
            || log "Warning: failed to restart ${entry}"
    fi
}

# Schedule a deferred restart (2s delay) for a service entry.
# Entry format: "servicename" or "user:UID:servicename"
restart_service_deferred() {
    local entry="$1"
    if [[ "$entry" == user:*:* ]]; then
        local uid="${entry#user:}"
        uid="${uid%%:*}"
        local svc="${entry#user:${uid}:}"
        local unit_name="restart-user${uid}-${svc%.service}"
        local username
        username=$(getent passwd "$uid" | cut -d: -f1)
        if [[ -z "$username" ]]; then
            log "Warning: no user found for uid ${uid}, skipping deferred restart of ${svc}"
            return 0
        fi
        log "Scheduling deferred user service restart (uid=${uid}): ${svc}"
        systemd-run --no-block --on-active=2 --unit="$unit_name" \
            /bin/bash -c "export XDG_RUNTIME_DIR=/run/user/${uid}
export DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/${uid}/bus
[[ \"\$(runuser -u '${username}' -- systemctl --user is-enabled '${svc}' 2>/dev/null)\" == masked ]] \
    && runuser -u '${username}' -- systemctl --user unmask '${svc}'
runuser -u '${username}' -- systemctl --user restart '${svc}'" \
            2>/dev/null || true
    else
        local unit_name="restart-${entry%.service}"
        log "Scheduling deferred restart: ${entry}"
        systemd-run --no-block --on-active=2 --unit="$unit_name" \
            /bin/bash -c "
[[ \"\$(systemctl is-enabled '${entry}' 2>/dev/null)\" == masked ]] \
    && systemctl unmask '${entry}'
systemctl restart '${entry}'" \
            2>/dev/null || true
    fi
}

# --- Module management ---

start_modules() {
    local blacklist_entries=()
    local loaded_modules=()

    for mod in "${CONFLICT_MODULES[@]}"; do
        if is_module_loaded "$mod"; then
            blacklist_entries+=("blacklist ${mod}")
            loaded_modules+=("$mod")
        fi
    done

    if [[ ${#loaded_modules[@]} -eq 0 ]]; then
        log "No conflicting modules loaded"
        return 0
    fi

    mkdir -p "$HHD_BLACKLIST_DIR"
    printf '%s\n' "${blacklist_entries[@]}" > "$HHD_BLACKLIST_FILE"
    log "Blacklisted: ${loaded_modules[*]}"

    for mod in "${loaded_modules[@]}"; do
        log "Unloading: ${mod}"
        modprobe -r "$mod" 2>/dev/null || log "Warning: failed to unload ${mod}"
    done
}

stop_modules() {
    if [[ ! -f "$HHD_BLACKLIST_FILE" ]]; then
        log "No blacklist file found, nothing to restore"
        return 0
    fi

    local modules=()
    while IFS= read -r line; do
        if [[ "$line" =~ ^blacklist[[:space:]]+(.+) ]]; then
            modules+=("${BASH_REMATCH[1]}")
        fi
    done < "$HHD_BLACKLIST_FILE"

    rm -f "$HHD_BLACKLIST_FILE"
    log "Removed blacklist file"

    for mod in "${modules[@]}"; do
        if ! is_module_loaded "$mod"; then
            log "Reloading: ${mod}"
            modprobe "$mod" 2>/dev/null || log "Warning: failed to reload ${mod}"
        fi
    done
}

# --- Service management ---

start_services() {
    for svc in "${CONFLICT_SERVICES[@]}"; do
        local svc_state
        svc_state=$(systemctl is-enabled "$svc" 2>/dev/null || true)
        if systemctl is-active --quiet "$svc" 2>/dev/null; then
            log "Stopping conflicting service: ${svc}"
            systemctl stop "$svc" 2>/dev/null || true
        fi
        if [[ "$svc_state" == "enabled" ]]; then
            log "Masking conflicting service: ${svc}"
            systemctl mask "$svc" 2>/dev/null || true
        fi
    done

    for entry in "${RESTART_ON_START_SERVICES[@]}"; do
        restart_service_now "$entry"
    done
}

stop_services() {
    for svc in "${CONFLICT_SERVICES[@]}"; do
        local svc_state
        svc_state=$(systemctl is-enabled "$svc" 2>/dev/null || true)
        if [[ "$svc_state" == "masked" ]]; then
            log "Unmasking service: ${svc}"
            systemctl unmask "$svc" 2>/dev/null || true
        fi
    done

    for entry in "${RESTART_ON_STOP_SERVICES[@]}"; do
        restart_service_deferred "$entry"
    done
}

# --- Power key management ---

reload_logind() {
    systemctl kill -s HUP systemd-logind 2>/dev/null || true
}

start_powerkey() {
    if [[ -f "$POWERKEY_IGNORE_CONF" ]]; then
        log "Removing power key ignore (hhd handles power key)"
        rm -f "$POWERKEY_IGNORE_CONF"
        reload_logind
    fi
}

stop_powerkey() {
    if [[ ! -f "$POWERKEY_IGNORE_CONF" ]]; then
        log "Restoring power key ignore"
        mkdir -p "$(dirname "$POWERKEY_IGNORE_CONF")"
        printf '[Login]\nHandlePowerKey=ignore\n' > "$POWERKEY_IGNORE_CONF"
        reload_logind
    fi
}

# --- Entry points ---

do_start() {
    start_modules
    start_powerkey
    start_services
}

do_stop() {
    stop_modules
    stop_powerkey
    stop_services
}

case "${1}" in
    start)
        do_start
        ;;
    stop)
        do_stop
        ;;
    *)
        echo "Usage: $(basename "$0") {start|stop}"
        exit 1
        ;;
esac
